<!DOCTYPE html>
<html lang = "en">
    <head>
        <meta charset = "UTF-8" />
        <title> Evolution Simulation</title>
        <style>
            html, body {
                margin: 0;
                background-color: black;
                overflow: hidden;
                color: white;
                font-family: monospace;
            }
            #ui {
                position: fixed;
                top: 10px; 
                left: 10px;
                font-size: 14px;
                padding: 6px 10px;
                background: black;
                border: 1px solid white;
            }

            #controls {
                position: fixed;
                bottom: 15px;
                left: 15px;
                color : white;
                font-size : 12px;
            }
            #controls label {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
            }
            #controls input[type=range] {
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
                cursor: pointer;
            }
            #controls input[type=range]::-webkit-slider-runnable-track{
                height: 5px;
                background: black;
                border: 1px solid white;
            }
            #controls input[type=range]::-moz-range-track {
                height:5px;
                background: black;
                border: 1px solid white;
            }
            #controls input[type=range]::-webkit-slider-thumb{
                -webkit-appearance: none;
                appearance: none;
                width: 3px;
                height: 12px;
                background: white;
                border-radius: 20%;
            }
            #controls input[type=range]::-moz-range-thumb {
                width: 3px;
                height: 12px;
                background: white;
                border-radius: 20%;
            }
            #time_controls button {
                background: black;
                color: white;
                border: 1px solid white;
                margin-left: 4px;
                cursor: pointer;
                font-family: monospace;
            }
            #time_controls button.active {
                background: White;
                color: black;
            }

        </style>
    </head>
    <body>
    <canvas id="c"></canvas>
    <div id = "controls">
        <label>
            Mutation
            <input type = "range" min = "0.001" max = "0.1" step = "0.001" value = "0.03" id = "mut">
        </label>
        <label>
            Metabolism
            <input type = "range" min = "0.001" max = "0.1" step = "0.001" value = "0.008" id = "meta">
        </label>
        <label>
            Energy Gain
            <input type = "range" min = "1" max = "50" step = "1" value = "18" id = "energy">
        </label>
        <label>
            Decay
            <input type = "range" min = "0" max = "0.003" step = "0.00001" value = "0.001" id = "decay">
        </label>
    </div>
    <div id="ui"></div>

    <button id="graph_button" style="
        position: fixed;
        top: 10px;
        right: 20px;
        background: black;
        color: white;
        border: 1px solid white;
        font-family: monospace;
        cursor: pointer;
    ">
        GRAPH
    </button>

    <button id="graph_mode_button" style ="
        position: fixed;
        top: 10px;
        right: 75px;
        background: black;
        color: white;
        border: 1px solid white;
        font-family: monospace;
        cursor: pointer;
    ">
        POPULATION
    </button>

    <div id = "time_controls" style = "
        position: fixed;
        top: 10px;
        right: 700px;
        font-family: monospace;
    ">
        <button data-scale = "1">x1</button>
        <button data-scale = "5">x5</button>
        <button data-scale= "10">x10</button>
    </div>

    <script>
        
        const params = {
            mutation: 0.03,
            metabolism: 0.008,
            energyGain: 19,
            decay: 0.0001,
        };

        const mut = document.getElementById("mut");
        const meta = document.getElementById("meta");
        const energy = document.getElementById("energy");
        const decay = document.getElementById("decay");

        const timeButtons = document.querySelectorAll("#time_controls button");
        timeButtons.forEach(btn => {
            btn.onclick = () => {
                timeScale = +btn.dataset.scale;
                timeButtons.forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
            };
        });
        timeButtons[0].classList.add("active");

        let timeScale = 1;
        let uiTimer = 0;
        let graphTimer = 0;
        let graphMode = "population";
        const graphModeButton = document.getElementById("graph_mode_button");
        graphModeButton.onclick = () => {
            graphMode = graphMode === "population" ? "deaths" : "population";
            graphModeButton.textContent = 
            graphMode === "population" ? "POPULATION" : "DEATHS";
        };
        const dt = 1 / timeScale;

        let LINEAGE_ID =0;
        const lineageStats = new Map();

        let totalDeaths = 0;
        const deathHistory = [];
        
        
        let showGraph = false;
        document.getElementById("graph_button").onclick = () => {
            showGraph = !showGraph;
        };
        const popHistory = [];
        const MAX_HISTORY = 500;

        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");
        const ui = document.getElementById("ui");

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener("resize", resize);
        resize();

        // BASE PARAMETERS
        const START_POP = 50;

            // ORGANISM
            class Organism {
                constructor(x, y, parent = null, startSize = null) {
                    if (startSize !== null) {
                        this.size = startSize;
                        this.speed = rand(0.3, 1);
                        this.activity = Math.random();
                        this.lineage = parent.lineage;
                        this.generation = parent.generation + 1;
                    } 
                    else if (parent) {
                        this.size = parent.size * rand(1 - params.mutation, 1 + params.mutation);
                        this.speed = parent.speed * rand(1 - params.mutation, 1 + params.mutation);
                        this.activity = clamp(parent.activity + rand(-0.5, 0.5), 0, 1);
                        this.lineage = parent.lineage;
                        this.generation = parent.generation + 1;
                    } 
                    else {
                        this.size = rand(0.5, 5);
                        this.speed = rand(0.3, 1);
                        this.activity = Math.random()
                        this.lineage = LINEAGE_ID++;
                        this.generation = 0;
                        lineageStats.set(this.lineage, {
                            alive: 0,
                            extinct: false,
                            maxGen: 0
                        });
                    }
                    lineageStats.get(this.lineage).alive++;

                    this.energy = this.size * 15;
                    this.x = x;
                    this.y = y;
                    this.vx = rand(-1, 1);
                    this.vy = rand(-1, 1);
                    this.dead = false;
                }
                
                update(list) {
                    //movement
                    if (Math.random() < this.activity) {
                        const target = this.findPrey(list);
                        if (target) {
                            const dx = target.x - this.x;
                            const dy = target.y - this.y;
                            const d = Math.hypot(dx, dy) || 1;
                            this.vx = dx / d;
                            this.vy = dy / d;
                        }

                }
                this.size -= params.decay * this.size; 
                this.x += this.vx * this.speed * dt;
                this.y += this.vy * this.speed * dt;

                    wrap(this);
                    // energy
                    this.energy -= params.metabolism * (this.size ** 1.5 + this.speed * 5);
                    // reproduction
                    if (this.energy > this.size * 15) {
                        this.energy *= 0.7;
                        list.push(new Organism(this.x, this.y, this));
                    }

                    if (this.energy <= 0 && !this.dead) {
                        this.dead = true; 
                        totalDeaths++;

                        const stats = lineageStats.get(this.lineage);
                        if (stats) {
                            stats.alive--;
                            if (stats.alive === 0) {
                                stats.extinct = true;
                            }
                            stats.maxGen = Math.max(stats.maxGen, this.generation);
                        }
                     
                        if (this.size > 2) {
                            const numSplits = Math.floor(rand(1, 3));
                            const childSize = this.size / numSplits;
                        for (let i = 0; i < numSplits; i++) {
                            if (childSize > 0.5) {
                                list.push(
                                    new Organism(
                                        this.x + rand(-6, 6),
                                        this.y + rand(-6, 6),
                                        this,
                                        childSize
                                    ));
                            }
                        }
                    }
                    }
                }
                findPrey(list) {
                    let best = null;
                    let dist = Infinity;
                    for (const o of list) {
                        if (o == this || o.dead) continue;
                        if (this.size > o.size) {
                            const d = distance(this, o);
                            if (d < dist && d < 100) {
                                dist = d;
                                best = o;
                            }
                        }

                    }

                    return best;
                }    
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = "white";
                    ctx.fill();
                }
                }

            // UTILS
            function rand(a, b) {
                return a + Math.random() * (b - a);
            }
            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }
            function distance (a,b) {
                return Math.hypot(a.x - b.x, a.y - b.y);
            }
            function wrap(o) {
                if (o.x < 0) o.x += canvas.width;
                if (o.y < 0) o.y += canvas.height;
                if (o.x > canvas.width) o.x -= canvas.width;
                if (o.y > canvas.height) o.y -= canvas.height;
            }
            function getDominantLineage() {
                let best = null;
                for (const [id, data] of lineageStats.entries()) {
                    if (!best || data.alive > best.alive) {
                        best = {id, ...data};
                    }
                }
                return best;
            }

            function lineageCounts() {
                let total = lineageStats.size;
                let extinct = 0;
                for (const l of lineageStats.values()) {
                    if (l.extinct) extinct++;
                }
                return {
                    total, 
                    extinct,
                    alive: total - extinct
                };
            }

            // SIMULATION LOOP
            let organisms = [];
            for (let i = 0; i < START_POP; i++) {
                organisms.push(
                    new Organism(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height
                    )
                );
            }

            function checkPredation() {
                    for (const a of organisms) {
                        for (const b of organisms) {
                            if (a === b || a.dead || b.dead) continue;
                            const dx = a.x - b.x;
                            const dy = a.y - b.y;
                                if (dx*dx + dy*dy < a.size*a.size && a.size > b.size*1.2) {
                                    a.energy += b.size * params.energyGain;
                                    b.dead = true;
                                }
                            }
                        }
                    }
            
            let frameCount = 0;

            function computeStats(list) {
                let size = 0, speed = 0, activity = 0, predators = 0;

                for (const o of list) {
                    size += o.size;
                    speed += o.speed;
                    activity += o.activity;
                    if (o.size > 3) predators++;
                }
                const n = list.length || 1;
                return {
                    avgSize: (size/n).toFixed(2),
                    avgSpeed: (speed/n).toFixed(2),
                    avgActivity: (activity/n).toFixed(2),
                    predatorRatio: ((predators/n) * 100).toFixed(1)
                };
            }
            

            function drawGraph() {
                const w = 500;
                const h = 300;
                const x = canvas.width - w - 10;
                const y = 20;

                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.fillRect(x, y, w, h);

                ctx.strokeStyle = "white";
                ctx.strokeRect(x, y, w, h);

                const data = 
                    graphMode === "population" ? popHistory : deathHistory;

                if (data.length < 2) return;
                const maxVal = Math.max(...data, 1);

                ctx.strokeStyle =
                    graphMode === "population"
                    ? "white"
                    : "rgba(255, 255, 255, 0.9)";


                ctx.beginPath();
                data.forEach((v, i) => {
                    const px = x + (i/(MAX_HISTORY - 1)) * w;
                    const py = y + h - (v/maxVal) * h;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.stroke();

                ctx.fillStyle = "white";
                ctx.font = "10px monospace";
                ctx.fillText(
                    graphMode === "population" ? "Population" : "Deaths",
                    x + 10, 
                    y + 15
                );
            }

            const targets = {...params};
            mut.oninput = () => targets.mutation = +mut.value;
            meta.oninput = () => targets.metabolism = +meta.value;
            energy.oninput = () => targets.energyGain = +energy.value;
            decay.oninput = () => targets.decay = +decay.value;

            function updateParams() {
                params.mutation += (targets.mutation - params.mutation) * 0.1;
                params.metabolism += (targets.metabolism - params.metabolism) * 0.1;
                params.energyGain += (targets.energyGain - params.energyGain) * 0.1;
                params.decay += (targets.decay - params.decay) * 0.002;
            }

            function step() {
                for (let t = 0; t < timeScale; t++) {
                    for (const o of organisms) o.update(organisms);
                    if (frameCount % (15 * timeScale) === 0) checkPredation();
                    organisms = organisms.filter(o => !o.dead);
                    frameCount++;
                }
                uiTimer += timeScale;
                graphTimer += timeScale;

                updateParams();

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (graphTimer >= 10) {
                    popHistory.push(organisms.length);
                    deathHistory.push(totalDeaths);
                    if (popHistory.length > MAX_HISTORY) popHistory.shift();
                    if (deathHistory.length > MAX_HISTORY) deathHistory.shift()
                    graphTimer = 0;
                }

                if (uiTimer >= 10) {
                    const s = computeStats(organisms);
                    ui.innerHTML = `
                        Population: ${organisms.length}<br>
                        Avg Size: ${s.avgSize}<br>
                        Avg Speed: ${s.avgSpeed}<br>
                        Avg Activity: ${s.avgActivity}<br>
                        Predators: ${s.predatorRatio}%<br>
                        Time Scale: x${timeScale}<br>
                        Deaths: ${totalDeaths}
                    `;
                    const dom = getDominantLineage();
                    if (dom) {
                        ui.innerHTML += `<br>Dominant Lineage: ${dom.id} (Gen ${dom.maxGen})`;
                    }
                    uiTimer = 0;
                }
                for (const o of organisms) o.draw();
                if (showGraph) drawGraph();
                requestAnimationFrame(step);
            }
        step();
    </script>
    </body>
</html>
